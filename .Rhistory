load(here("data.Rdata"))
library(tidyverse)
library(tidyverse)
library(glmnet)
library(caret)
library(here)
#Make the code reproducible
set.seed(123)
#load the data
load(here("data.Rdata"))
glimpse(data)
plot_missing(data)
DataExplorer::plot_missing(data)
library(tidyverse)
library(glmnet)
library(caret)
library(here)
#Make the code reproducible
set.seed(123)
#load the data
load(here("data.Rdata"))
glimpse(data)
data = data %>%
select(-cycle_r_i)
?createDataPartition
train.index <- caret::createDataPartition(data$pcos_y_n, p = .75)
train.index <- caret::createDataPartition(data$pcos_y_n, p = .75, list=FALSE)
train <- data[ train.index,]
valid  <- data[-train.index,]
table(train$pcos_y_n)
table(valid$pcos_y_n)
table(train$pcos_y_n)[1]/ table(train$pcos_y_n)[2]
table(valid$pcos_y_n)[1]/ table(valid$pcos_y_n)[2]
table(data$pcos_y_n)[1]/ table(data$pcos_y_n)[2]
View(data)
data = data %>%
select(-cycle_r_i) %>%
column_to_rownames("patient_file_no")
#load the data
load(here("data.Rdata"))
data = data %>%
select(-cycle_r_i) %>%
column_to_rownames("patient_file_no")
#convert training data to matrix format
x <- model.matrix(pcos_y_n~.,train)
glimpse(data)
#convert class to numerical variable
y <- ifelse(train$pcos_y_n=="1",1,0)
glimpse(train)
glimpse(y)
train <- data[ train.index,]
valid  <- data[-train.index,]
#convert training data to matrix format
x <- model.matrix(pcos_y_n~.,train)
#convert class to numerical variable
y <- ifelse(train$pcos_y_n=="1",1,0)
?cv.glmnet
?glmnet
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
#convert class to numerical variable
response <- ifelse(train$pcos_y_n=="1",1,0)
ridge.cv <- cv.glmnet(x_matrix,response,alpha=0,
family="binomial",type.measure = "class" )
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
#convert class to numerical variable
response <- ifelse(train$pcos_y_n=="1",1,0)
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso, alpha=0 for ridge
# check docs to explore other type.measure options
#
ridge.cv <- cv.glmnet(x_matrix,response,alpha=0,
family="binomial",type.measure = "class" )
train <- data[ train.index,]
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
#convert class to numerical variable
response <- ifelse(train$pcos_y_n=="1",1,0)
#perform grid search to find optimal value of lambda
#family= binomial => logistic regression, alpha=1 => lasso, alpha=0 for ridge
# check docs to explore other type.measure options
#
ridge.cv <- cv.glmnet(x_matrix,response,alpha=0,
family="binomial",type.measure = "class" )
View(x_matrix)
?model.matrix
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
x_matrix <- model.matrix(pcos_y_n~.,train)
library(tidyverse)
library(glmnet)
library(caret)
library(here)
#Make the code reproducible
set.seed(123)
#load the data
load(here("data.Rdata"))
glimpse(data)
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
library(tidyverse)
library(glmnet)
library(caret)
library(here)
#Make the code reproducible
set.seed(123)
#load the data
load(here("data.Rdata"))
glimpse(data)
data = data %>%
select(-cycle_r_i) %>%
column_to_rownames("patient_file_no")
#Split the data into a training and a validation set
train.index <- caret::createDataPartition(data$pcos_y_n, p = .75, list=FALSE)
train <- data[ train.index,]
valid  <- data[-train.index,]
#Check the negative/positive ration in the validation set
table(train$pcos_y_n)
table(train$pcos_y_n)[1]/ table(train$pcos_y_n)[2]
#Check the negative/positive ration in the validation set
table(valid$pcos_y_n)
table(valid$pcos_y_n)[1]/ table(valid$pcos_y_n)[2]
#Check the negative/positive ration in the original data set
table(data$pcos_y_n)[1]/ table(data$pcos_y_n)[2]
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
#convert class to numerical variable
response <- ifelse(train$pcos_y_n=="1",1,0)
ridge.cv <- cv.glmnet(x_matrix,response,alpha=0,
family="binomial",type.measure = "class" )
?model.matrix
View(x_matrix)
length(train$pcos_y_n)
train
x_matrix
DataExplorer::plot_missing(train)
#Split the data into a training and a validation set
data_logistic = data %>%
drop_na()
train.index <- caret::createDataPartition(data_logistic$pcos_y_n, p = .75, list=FALSE)
train <- data_logistic[ train.index,]
valid  <- data_logistic[-train.index,]
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
response <- ifelse(train$pcos_y_n=="1",1,0)
ridge.cv <- cv.glmnet(x_matrix,response,alpha=0,
family="binomial",type.measure = "class" )
DataExplorer::plot_missing(data)
#Split the data into a training and a validation set
data_complete_cases = data %>%
drop_na()
train.index <- caret::createDataPartition(data_complete_cases$pcos_y_n, p = .75, list=FALSE)
train <- data_complete_cases[ train.index,]
valid  <- data_complete_cases[-train.index,]
#Make the code reproducible
set.seed(123)
#Check the negative/positive ration in the validation set
table(train$pcos_y_n)
table(train$pcos_y_n)[1]/ table(train$pcos_y_n)[2]
#Check the negative/positive ration in the validation set
table(valid$pcos_y_n)
table(valid$pcos_y_n)[1]/ table(valid$pcos_y_n)[2]
#Check the negative/positive ration in the original data set
table(data$pcos_y_n)[1]/ table(data$pcos_y_n)[2]
#Check the negative/positive ration in the original data set
table(data_complete_cases$pcos_y_n)[1]/ table(data_complete_cases$pcos_y_n)[2]
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
x_matrix
#convert training data to matrix format
x_matrix <- model.matrix(pcos_y_n~.,train)
#convert class to numerical variable
response <- ifelse(train$pcos_y_n=="1",1,0)
ridge.cv <- cv.glmnet(x_matrix,response,alpha=0,
family="binomial",type.measure = "class" )
#plot result
plot(ridge.cv)
?ridge.cv
?cv.glmnet
knitr::opts_chunk$set(echo = TRUE)
#min value of lambda
ridge.cv$lambda.min
#best value of lambda
lambda_RIDGE <- ridge.cv$lambda.1se
data_complete_cases
#best value of lambda
lambda_RIDGE <- ridge.cv$lambda.1se
lambda_RIDGE
ridge.cv$lambda.1se
#min value of lambda
ridge.cv$lambda.min
ridge.cv$lambda.1se
coef(ridge.cv,s=ridge.cv$lambda.1se)
?coef
ridge.cv
